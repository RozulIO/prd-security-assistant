# GEMINI.md - Development Plan: AI-Guided Risk Assessment Assistant

**Project Goal:** Build a Streamlit application that accepts a System Design/PRD document (DOCX), parses it, and uses Google Gemini (via LangChain) to perform a STRIDE-based security risk assessment.

**Author:** AdriÃ¡n Puente Z. (ch0ks)
**Organization:** Rozul IO
**Target Stack:** Python, Streamlit, LangChain, Google Gemini API, Render.

---

## Phase 1: Environment & Setup

### 1.1 Prerequisites
- Python 3.9+ installed.
- Google AI Studio API Key (Gemini).
- GitHub Account (for version control).
- Render Account (for deployment).

### 1.2 Dependencies (`requirements.txt`)
Create a `requirements.txt` file with the following libraries:
```
streamlit
langchain
langchain-google-genai
langchain-community
python-docx
docx2txt
python-dotenv
```

### 1.3 Environment Variables
- Create a `.env` file for local development (do not commit to GitHub).
- Variables needed:
    - `GOOGLE_API_KEY=your_actual_api_key`
    - `PORT=8080` (Default Streamlit port)
    - `MODELAI=gemini-flash-latest` (Or your preferred model version)

### 1.4 Automation with Makefile
To streamline common development and deployment tasks, a `Makefile` will be created. It will include documented targets for:
- `install`: Install project dependencies.
- `run`: Start the Streamlit application.
- `clean`: Remove temporary files and logs.
- `lint`: Run linting/formatting checks (future enhancement).

---

## Phase 2: Core Logic (Backend)
**Objective:** Create the function that processes the DOCX and queries Gemini.

### 2.1 DOCX Handling strategy
Since Streamlit `file_uploader` returns a ByteIO object, but LangChain loaders often prefer file paths, we will implement a temporary file handling strategy:
1. Receive file from Streamlit.
2. Save explicitly to a `./temp/` directory (ensure this directory exists).
3. Load using `Docx2txtLoader`.
4. Clean up (delete) the temp file immediately after processing.

### 2.2 LangChain & Gemini Integration
**Prompt Template:**
We need a strict system prompt to enforce the "Security Engineer" persona. The prompt now asks for a JSON array output to facilitate structured data handling.

> "You are a Senior Security Engineer. You are analyzing a product requirement document.
> Apply the STRIDE threat modeling methodology to the following system description.
> Identify potential threats and return the output as a strictly formatted JSON array of objects. 
> Each object must have the following keys:
> - "Feature Name": The specific feature or component affected.
> - "Threat Type": The STRIDE category (Spoofing, Tampering, etc.).
> - "Description": A description of the threat.
> - "Risk": The potential impact or consequence.
> - "Recommendation": Mitigation steps.
> - "Risk Level": High, Medium, or Low."

**Report Narrative Generation:**
A separate LLM call generates the narrative sections (Executive Summary, Introduction, Scope, Methodology, Conclusion) in Markdown format.

---

## Phase 3: UI Implementation (Streamlit & Styling)

### 3.1 Styling Strategy (Bootstrap-esque)
Streamlit does not support native Bootstrap classes, so we will inject custom CSS via `st.markdown(..., unsafe_allow_html=True)` to achieve the "Web App" aesthetic. Custom CSS has been added to force primary buttons to a blue color.
- **Fonts:** Use a clean sans-serif font (Inter or Roboto).
- **Header:** Custom HTML header with a Shield/Lock SVG and App Name.
- **Footer:** Fixed footer with "Rosul IO all rights reserved".

### 3.2 Layout Structure (`app.py`)
1. **Configuration:** Set page config (Title, Icon, Layout='centered').
2. **Custom CSS:** Inject styles for the footer and header, including button styling.
3. **Header:** Display the Icon and App Name.
4. **Main Container (Home Page):**
   - **Input:** `st.file_uploader` (Label: "Upload your PRD/Spec", type: `['docx']`).
   - **Action:** `st.button("Perform Security Assessment", type="primary")`.
   - **Output Area:** Displays the risk assessment in a `st.dataframe`.
   - **Actions:** "Download Table as CSV" (button) and "Generate Full Report" (button), placed side-by-side.
5. **Report Page:**
   - Activated by the "Generate Full Report" button.
   - Displays a comprehensive report (Markdown) generated by the LLM, including an Executive Summary, Introduction, Scope, Methodology, Risk Assessment (table), and Conclusion.
   - **Actions:** "Download Report (Markdown)" (button) and "Download Report (PDF)" (button), placed side-by-side.
   - Includes a "Back to Assessment" button.
6. **Session State Management:** Report data (risk table, full Markdown report) is cached in `st.session_state` to prevent redundant regeneration and improve user experience.
7. **Footer:** Simple text centered at the bottom.

**Note on Authentication:**
*Current version lacks authentication.* The app will be publicly accessible if deployed.

---

## Phase 4: Deployment (Render)

### 4.1 Repository Preparation
- Ensure `app.py`, `requirements.txt`, and this `GEMINI.md` are in the root.
- Add `.gitignore` to exclude `venv/`, `.env`, `temp/`, and `__pycache__/`.

### 4.2 Render Web Service Configuration
- **Runtime:** Python 3.
- **Build Command:** `pip install -r requirements.txt`
- **Start Command:** `streamlit run app.py --server.port $PORT --server.address 0.0.0.0`
- **Environment Variables:**
    - `GOOGLE_API_KEY`: (Value from AI Studio)
    - `MODELAI`: `gemini-1.5-flash` (or `gemini-pro`)

---

## Phase 5: Observability

### 5.1 Logging Strategy
To ensure operational visibility and easier debugging, we implement a robust logging system using Python's built-in `logging` module.

- **Dual Handlers:**
  - **Console (StreamHandler):** For real-time logs during development or in container logs.
  - **File (FileHandler):** Writes to `app.log` for persistent storage of session data.
- **Log Level:** Set to `INFO` to capture key application lifecycle events without excessive noise.
- **Format:** `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
- **Key Events Tracked:**
  - Application startup.
  - File upload and temporary storage paths.
  - Document loading and cleanup success/failure.
  - Risk assessment start/completion.
  - Exceptions and error details.

---

## Code Snippets for Implementation

*(Note: Full implementation is available in `app.py`)*

### A. Logging Configuration
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)
```

### B. Updated Logic with Logging
The helper functions (`load_docx`, `analyze_risk`) now include `logger.info()` and `logger.error()` calls to trace execution flow and capture exceptions gracefully before raising them to the UI layer.
